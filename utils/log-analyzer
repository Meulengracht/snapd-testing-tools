#!/bin/bash

show_help() {
    echo "usage: log-analyzer get-failed-tasks <PARSED-LOG>"
    echo "       log-analyzer get-successful-tasks <PARSED-LOG>"
    echo "       log-analyzer get-aborted-tasks <PARSED-LOG>"
    echo "       log-analyzer get-total-tasks <PARSED-LOG>"
    echo "       log-analyzer get-failed <task|suite|project> <prepare|restore> <PARSED-LOG>"
    echo "       log-analyzer list-failed <task|suite|project> <prepare|restore> <PARSED-LOG>"
    echo "       log-analyzer list-failed-tasks <PARSED-LOG>"
    echo "       log-analyzer list-executed-tasks <PARSED-LOG>"
    echo "       log-analyzer list-successful-tasks <PARSED-LOG>"
    echo "       log-analyzer list-aborted-tasks <EXEC-PARAM> <PARSED-LOG>"
    echo "       log-analyzer list-reexecute-tasks <EXEC-PARAM> <PARSED-LOG>"
    echo ""
    echo "Get general information about the current system"
    echo ""
    echo "Available options:"
    echo "  -h --help   show this help message."
    echo ""
    echo "COMMANDS:"
    echo "  get-failed-tasks:        retrieves the number of failed tasks during preapre, execute or restore"
    echo "  get-successful-tasks:    retrieves the number of successful tasks"
    echo "  get-aborted-tasks:       retrieves the number of aborted tasks"
    echo "  get-total-tasks          retrieves the number of successful, failed and aborted tasst"
    echo "  get-failed               retrieves the number of failed tasks, suites or projects while preparing or restoring"
    echo "  list-failed              list the failed tasks, suites or projects while preparing or restoring"
    echo "  list-failed-tasks        list the tasks which failed during execute"
    echo "  list-executed-tasks      list the tasks that were executed"
    echo "  list-successful-tasks    list the successful tasks"
    echo "  list-aborted-tasks       list the aborted tasks (needs spread to be installed)"
    echo "  list-reexecute-tasks     list the tasks to re-execute to complete (includes aborted and failed tasks)"
    echo ""
    echo "PARSED-LOG: This is the output generated by the log-parser tool"
    echo "EXEC-PARAM: this is the parameter used to run spread (something like this BACKEND:SYSTEM:SUITE)"
    echo ""
}

_check_log() {
    local log="$1"

    if [ -z "$log" ]; then
        echo "log.analyzer: the log file cannot be empty"
        exit 1
    elif [ ! -f "$log" ]; then
        echo "log.analyzer: the log file $log does not exist"
        exit 1
    fi
}

get_successful_tasks() {
    local log="$1"
    _check_log "$log"

    TESTS_SUCCESSFUL=$(jq -r '.[] | select( .type == "result") | ( select( .result_type == "Successful") | .number ) // 0 ' "$log" | awk '{s+=$1} END {print s}')
    # shellcheck disable=SC2086
    test $TESTS_SUCCESSFUL -gt 0
    echo "$TESTS_SUCCESSFUL"
}

get_failed_tasks() {
    local log="$1"
    _check_log "$log"

    TESTS_FAILED=$(jq -r '.[] | select( .type == "result") | ( select( .result_type == "Failed") | .number ) // 0 ' "$log" | awk '{s+=$1} END {print s}')
    # shellcheck disable=SC2086
    test $TESTS_FAILED -gt 0
    echo "$TESTS_FAILED"
}

get_aborted_tasks() {
    local log="$1"
    _check_log "$log"

    TESTS_ABORTED=$(jq -r '.[] | select( .type == "result") | ( select( .result_type == "Aborted") | .number ) // 0 ' "$log" | awk '{s+=$1} END {print s}')
    # shellcheck disable=SC2086
    test $TESTS_ABORTED -gt 0
    echo "$TESTS_ABORTED"
}

get_total_tasks(){
    local log="$1"
    _check_log "$log"

    TESTS_SUCCESSFUL=$(get_successful_tasks "$log")
    TESTS_FAILED=$(get_failed_tasks "$log")
    TESTS_ABORTED=$(get_aborted_tasks "$log")
    echo "$((TESTS_SUCCESSFUL+TESTS_FAILED+TESTS_ABORTED))"
}

list_failed_tasks() {
    local log="$1"
    _check_log "$log"

    jq -r '.[] | select( .type == "result") | select( .result_type == "Failed")  | select(.level == "tasks") | .detail.lines[]' "$log" | cut -d '-' -f2- | xargs
}

list_failed() {
    local level="$1"
    local stage="$2"
    local log="$3"

    if [ -z "$level" ]; then
        echo "log.analyzer: the first parameter cannot be empty"
        exit 1
    elif [ ! "$level" = 'task' ] && [ ! "$level" = 'suite' ] && [ ! "$level" = 'project' ]; then
        echo "log.analyzer: the first parameter has to be: task, suite or project"
        exit 1
    fi

    if [ -z "$stage" ]; then
        echo "log.analyzer: the second parameter cannot be empty"
        exit 1
    elif [ ! "$stage" = 'prepare' ] && [ ! "$stage" = 'restore' ]; then
        echo "log.analyzer: the second parameter has to be: prepare or restore"
        exit 1
    fi
    _check_log "$log"

    jq -r ".[] | select( .type == \"result\") | select( .result_type == \"Failed\")  | select(.level == \"$level\") | select(.stage == \"$stage\")  | .detail.lines[]" "$log" | cut -d '-' -f2- | xargs
}

get_failed() {
    local level="$1"
    local stage="$2"
    local log="$3"

    if [ -z "$level" ]; then
        echo "log.analyzer: the first parameter cannot be empty"
        exit 1
    elif [ ! "$level" = 'task' ] && [ ! "$level" = 'suite' ] && [ ! "$level" = 'project' ]; then
        echo "log.analyzer: the first parameter has to be: task, suite or project"
        exit 1
    fi

    if [ -z "$stage" ]; then
        echo "log.analyzer: the second parameter cannot be empty"
        exit 1
    elif [ ! "$stage" = 'prepare' ] && [ ! "$stage" = 'restore' ]; then
        echo "log.analyzer: the second parameter has to be: prepare or restore"
        exit 1
    fi
    _check_log "$log"

    jq -r ".[] | select( .type == \"result\") | ( select( .result_type == \"Failed\")  | ( select(.level == \"$level\") | ( select(.stage == \"$stage\")  | .number ))) // 0 " "$log" | awk '{s+=$1} END {print s}'
}

_merge_tasks_lists() {
    # Returns the list1 + the tasks in list2 which are not included in list1
    local list1="$1"
    local list2="$2"
    local merged_list="$1"

    # shellcheck disable=SC2086
    for elem2 in $list2; do
        if [[ ! $list1 =~ (^|[[:space:]])$elem2($|[[:space:]]) ]]; then
            merged_list="$merged_list $elem2"
        fi
    done 
    echo "$merged_list"
}

_diff_tasks_lists() {
    # Returns the list1 - the tasks in list2
    local list1="$1"
    local list2="$2"
    local diff_list
    diff_list=""

    # shellcheck disable=SC2086
    for elem1 in $list1; do
        if [[ ! $list2 =~ (^|[[:space:]])$elem1($|[[:space:]]) ]]; then
            diff_list="$diff_list $elem1"
        fi
    done 
    echo "$diff_list"
}

_intersection_tasks_lists() {
    # Returns the tasks in list1 which are also in the list2
    local list1="$1"
    local list2="$2"
    local both_list
    both_list=""

    # shellcheck disable=SC2086
    for elem1 in $list1; do
        if [[ $list2 =~ (^|[[:space:]])$elem1($|[[:space:]]) ]]; then
            both_list="$both_list $elem1"
        fi
    done 
    echo "$both_list"
}

list_reexecute_tasks() {
    local exec_exp="$1"
    local log="$2"

    if [ -z "$exec_exp" ]; then
        echo "log.analyzer: execution expression for spread cannot be empty"
        exit 1
    fi 
    _check_log "$log"

    local aborted_tasks exec_and_failed_tasks all_tasks reexec_tasks
    aborted_tasks="$(list_aborted_tasks "$exec_exp" "$log")"
    all_tasks="$(_list_all_tasks "$exec_exp")"
    exec_and_failed_tasks="$(_list_executed_and_failed_tasks "$log")"

    # Remove the tasks which are not in the filter from the executed and failed
    exec_and_failed_tasks="$(_intersection_tasks_lists "$exec_and_failed_tasks" "$all_tasks" "$log")"
    reexec_tasks="$(_merge_tasks_lists "$aborted_tasks" "$exec_and_failed_tasks")"

    # In case all the tests are failed or aborted, then the execution expression is used to reexecute
    if [ "$(echo "$reexec_tasks" | wc -w)" = "$(echo "$all_tasks" | wc -w)" ]; then
        echo "$exec_exp"
        return 
    fi
    # When all the tests were successfull, then the execution expression is used to reexecute
    if [ "$(echo "$reexec_tasks" | wc -w)" = 0 ]; then
        echo "$exec_exp"
        return 
    fi
    echo "$reexec_tasks"
}

list_successful_tasks() {
    local log="$1"
    _check_log "$log"

    local executed_tasks failed_tasks_restore failed_tasks
    executed_tasks="$(list_executed_tasks "$log")"
    failed_tasks="$(list_failed_tasks "$log")"
    failed_tasks_restore="$(list_failed task restore "$log")"

    if [ -n "$failed_tasks_restore" ]; then
        failed_tasks="$(_merge_tasks_lists "$failed_tasks" "$failed_tasks_restore")"
    fi

    if [ -n "$failed_tasks" ]; then
        executed_tasks="$(_diff_tasks_lists "$executed_tasks" "$failed_tasks")"
    fi    
    
    echo "$executed_tasks"
}

list_executed_tasks() {
    local log="$1"
    _check_log "$log"
    jq -r '.[] | select( .type == "action") | select( .verb == "Executing") | .task' "$log"
}

_list_all_tasks() {
    local exec_exp="$1"
    if ! command -v spread >/dev/null; then
        echo "log.analyzer: spread tool is not installed, exiting..."
        exit 1
    fi

    # shellcheck disable=SC2086
    spread -list $exec_exp
}

_list_executed_and_failed_tasks() {
    local log="$1"
    _check_log "$log"

    local failed_tasks failed_tasks_restore failed_tasks_prepare exec_and_failed_tasks
    failed_tasks="$(list_failed_tasks "$log")"
    failed_tasks_prepare="$(list_failed task prepare "$log")"
    failed_tasks_restore="$(list_failed task restore "$log")"

    exec_and_failed_tasks="$(_merge_tasks_lists "$failed_tasks" "$failed_tasks_restore")"
    _diff_tasks_lists "$exec_and_failed_tasks" "$failed_tasks_prepare"
}

list_aborted_tasks() {
    local exec_exp="$1"
    local log="$2"

    if [ -z "$exec_exp" ]; then
        echo "log.analyzer: execution expression for spread cannot be empty"
        exit 1
    fi 
    _check_log "$log"

    local all_tasks executed_tasks failed_tasks_prepare failed_tasks_restore failed_tasks
    all_tasks="$(_list_all_tasks "$exec_exp")"
    executed_tasks="$(list_executed_tasks "$log")"
    failed_tasks="$(list_failed_tasks "$log")"
    failed_tasks_prepare="$(list_failed task prepare "$log")"
    failed_tasks_restore="$(list_failed task restore "$log")"

    # In case no tasks for the expression, the aborted list is empty
    if [ -z "$all_tasks" ]; then
        return
    fi

    # In case no tasks are successfully executed, all the tasks - the failed ones are the aborted
    if [ -z "$executed_tasks" ]; then
        exec_and_failed_tasks="$(_list_executed_and_failed_tasks "$log")"
        _diff_tasks_lists "$all_tasks" "$exec_and_failed_tasks"
        return
    fi
    
    # In other cases the aborted tasks are all the tasks - the executed - the that failed 
    _diff_tasks_lists "$all_tasks" "$executed_tasks"
}

main() {
    if [ $# -eq 0 ]; then
        show_help
        exit 0
    fi

    local subcommand="$1"
    local action=
    while [ $# -gt 0 ]; do
        case "$1" in
            -h|--help)
                show_help
                exit 0
                ;;
            *)
                action=$(echo "$subcommand" | tr '-' '_')
                shift
                break
                ;;
        esac
    done

    if [ -z "$(declare -f "$action")" ]; then
        echo "log.analyzer: no such command: $subcommand" >&2
        show_help
        exit 1
    fi

    "$action" "$@"
}

main "$@"

